/**
 * pong_states.cpp — HSM state/context classes for UI screens
 * Rockstar Presents Table Tennis (Xbox 360, 2006)
 *
 * Covers 8 classes:
 *   creditsData        — serialisable data container for credits roll assets
 *   creditsSettings    — serialisable settings for credits display params
 *   pongCreditsContext — HSM context managing the credits UI page group
 *   pongCreditsState   — HSM leaf state that drives the credits sequence
 *   pongLegalsContext  — HSM context for the legal/EULA display screen
 *   pongLegalsState    — HSM leaf state for the legals sequence
 *   pongDialogContext  — HSM context for dialog popups (MI layout)
 *   pongDialogState    — HSM leaf state for dialog popup sequences
 *
 * Architecture:
 *   creditsData / creditsSettings are pure data objects loaded from disk
 *   (fiAscii / rage::dataSingleton style).  They live as singletons and
 *   expose IsSupported(assetId) and RegisterFields() virtuals common to
 *   all Rockstar data assets.
 *
 *   The Context classes are rage::hsmContext subclasses (some with
 *   multiple inheritance, embedding a secondary base vtable at +0x14).
 *   They own UI page-group pointers and state flags.
 *
 *   The State classes inherit from pongAttractState and hold a back-pointer
 *   to their context.  The state machine calls Enter/Exit/GetContext in the
 *   usual HSM pattern.
 */

#include "pong_states.hpp"
struct pongPageGroup {
    void** vtable;
    void Open() { if (vtable) ((void(*)(void*))vtable[2])(this); }
    void Close() { if (vtable) ((void(*)(void*))vtable[3])(this); }
}; // forward definition

// ─────────────────────────────────────────────────────────────────────────────
// Forward declarations for helpers referenced in this file
// ─────────────────────────────────────────────────────────────────────────────
#include <cstdint>
#include <cstddef>

extern void atSingleton_9420(void* obj);           // @ 0x821A9420
extern void rage_free(void* ptr);                  // @ 0x820C00C0
extern void* xe_EC88(uint32_t size);               // @ 0x820DEC88
extern void nop_8240E6D0(const char* fmt, ...);    // @ 0x8240E6D0 — debug logger

// Field registration helper (rage serialization system)
extern void RegisterSerializedField(void* obj, const void* key, void* fieldPtr, const void* desc, uint32_t flags);

// ── Additional helpers used in pong_states.cpp ────────────────────────────

extern void  util_94B8(void* obj, void* arg);                         // @ 0x8234B8 - some util
extern void  pg_6000_g(void* obj);                         // page group helper
extern void  pongAttractState_Shutdown(void* state);       // attract state cleanup
extern void  xe_main_thread_init_0038();                   // thread init
extern void  InitializePageGroup(void* pageGroup);         // @ 0x8231F4C0 - page group constructor
extern void  rage_ADF8(void* obj, void* arg2 = nullptr);                         // rage helper

// Allocation macro (SDA[0] = main alloc table, slot 1 = Alloc)
extern uint32_t g_mainAllocTable[];  // SDA global
#define VTABLE_SLOT1(obj) (((void*(*)(void*, uint32_t, uint32_t))(*(void***)(obj))[1]))
#define VCALL_ALLOC(obj, size, align) VTABLE_SLOT1(obj)(obj, size, align)

extern void  atSingleton_F728_g(void* obj);                         // notify/clear
extern void* pg_0890_g(void* pageGroup);                            // page group helper
extern void  hsmContext_SetNextState_2800(void* ctx, int stateIdx); // HSM transition
extern void  hsmContext_RequestTransition(void* ctx, int idx);      // HSM request
extern bool  hsmContext_IsTransitioning(void* ctx);                 // HSM query


// Virtual call helpers
#define VCALL_slot20(obj, arg) \
    (((bool(*)(void*, uint32_t))(*(void***)(obj))[20])(obj, arg))
#define VCALL_slot19(obj) \
    (((const char*(*)(void*))(*(void***)(obj))[19])(obj))


// ─────────────────────────────────────────────────────────────────────────────
// External globals / singletons (resolved from SDA / .data)
// ─────────────────────────────────────────────────────────────────────────────

// g_hsmMgr        — the game's central HSM manager (resolved @ 0x8271A81C)
// g_creditsRoll   — credits-roll singleton (resolved @ 0x8271A358)
// g_gameSettings  — global game settings object (resolved @ 0x8271A320)

// Byte flag: credits roll is currently visible (@ 0x8260660E, SDA-26126)
extern uint8_t g_creditsRollVisible;   // @ 0x8260660E

// ─────────────────────────────────────────────────────────────────────────────
// creditsData  [vtable @ 0x820766EC]
// ─────────────────────────────────────────────────────────────────────────────

/**
 * creditsData::~creditsData  @ 0x8240C0B8  |  size: 0x68
 *
 * Destructor.  If this object has allocated a bone/entry array
 * (tracked via the count at +0x26 and pointer at +0x20) it frees it,
 * then calls up to the atSingleton destructor and conditionally
 * frees the object itself.
 */
creditsData::~creditsData() {
    // If we allocated an entry array, free it
    if (m_entryCount != 0) {
        rage_free(m_pEntries);
    }
    // Let the singleton base do its teardown
    atSingleton_9420(this);

    // Note: conditional self-free (shouldFree flag from caller) is
    // handled by the generated thunk; this body covers the non-freeing path.
}

/**
 * creditsData::IsSupported  @ 0x8240C070  |  size: 0x48
 *
 * Returns true if assetId matches any of the three asset-type IDs
 * registered for creditsData (checked against two global singletons).
 * Slot 20 in the vtable — used by the asset manager to route loads.
 */
bool creditsData::IsSupported(uint32_t assetId) const {
    // First global singleton ID check
    extern uint32_t g_creditsAssetId_A;   // @ lbl resolved from -32164+11188
    if (assetId == g_creditsAssetId_A) {
        return true;
    }
    // Second global ID check
    extern uint32_t g_creditsAssetId_B;   // @ lbl resolved from -32163-32708
    if (assetId == g_creditsAssetId_B) {
        return true;
    }
    // Third global ID check
    extern uint32_t g_creditsAssetId_C;   // @ lbl resolved from -32163-32712
    return (assetId == g_creditsAssetId_C);
}

/**
 * creditsData::RegisterFields  @ 0x8240C120  |  size: 0x64
 *
 * Registers the two serialisable fields of this data object with
 * the rage data system.  Slot 21 — called during asset load/bind.
 * Registers: m_pEntries (array at +24) and m_strName (string at +28).
 */
void creditsData::RegisterFields() {
    // Register m_pEntries array field
    extern const void* g_creditsEntriesFieldDesc;   // @ lbl_825CAF00 area
    extern const void* g_creditsEntriesSchema;      // @ lbl_82079E18 area
    RegisterSerializedField(this, &g_creditsEntriesSchema, &m_pEntries, &g_creditsEntriesFieldDesc, 0);

    // Register m_strName string field
    extern const void* g_creditsNameFieldDesc;
    extern const void* g_creditsNameSchema;
    RegisterSerializedField(this, &g_creditsNameSchema, &m_strName, &g_creditsNameFieldDesc, 0);
}

/**
 * creditsData::BuildActiveList  @ 0x8240C188  |  size: 0x134
 *
 * Slot 3.  Iterates the linked list rooted at m_pNodeList (+12),
 * counts nodes whose IsSupported check passes (slot 20 on each node),
 * allocates a pointer array for them, then fills it in a second pass.
 * The result is stored in m_pActiveEntries (+32) / m_activeCount (+38).
 *
 * Nodes that fail the filter are logged via nop_8240E6D0 with the
 * "BoneName" key @ 0x8203F2E0.
 */
void creditsData::BuildActiveList() {
    uint32_t validCount = 0;
    extern uint32_t g_creditsAssetId_A;   // used as the filter arg

    // First pass: count valid nodes
    void* node = m_pNodeList;
    while (node != nullptr) {
        bool supported = VCALL_slot20(node, g_creditsAssetId_A);
        if (supported) {
            ++validCount;
        } else {
            // Log BoneName mismatch
            const char* key = "BoneName";   // @ 0x8203F2E0
            const char* self_name = VCALL_slot19(node);
            const char* our_name  = VCALL_slot19(this);
            nop_8240E6D0(key, our_name, self_name);
        }
        node = *(void**)((uint8_t*)node + 8);   // node->m_pNext
    }

    // Allocate active-entry array (or nullptr if empty)
    void** activeArray = nullptr;
    if (validCount > 0) {
        uint32_t allocSize = validCount * sizeof(void*);
        activeArray = (void**)xe_EC88(allocSize);
    }
    m_pActiveEntries = activeArray;
    m_activeCount    = (uint16_t)validCount;

    // Second pass: fill active-entry array
    uint16_t insertIdx = 0;
    node = m_pNodeList;
    while (node != nullptr) {
        bool supported = VCALL_slot20(node, g_creditsAssetId_A);
        if (supported) {
            activeArray[insertIdx] = node;
            ++insertIdx;
        }
        node = *(void**)((uint8_t*)node + 8);
    }
}

/**
 * creditsData::GetKey  @ 0x8231F358  |  size: 0xC
 *
 * Slot 22.  Returns the static key string used to identify this
 * data class in the asset registry.  (Parallel to GetName/GetKey
 * pattern used across all data singleton classes.)
 */
const char* creditsData::GetKey() const {
    // Returns pointer to static string in .rdata @ 0x82062378
    static const char* k_key = (const char*)0x82062378;
    return k_key;
}

// ─────────────────────────────────────────────────────────────────────────────
// creditsSettings  [vtable @ 0x82076754]
// ─────────────────────────────────────────────────────────────────────────────

/**
 * creditsSettings::IsSupported  @ 0x8240C2C0  |  size: 0x48
 *
 * Slot 20.  Same three-ID check pattern as creditsData::IsSupported,
 * using a different primary ID pulled from the settings singleton table.
 */
bool creditsSettings::IsSupported(uint32_t assetId) const {
    extern uint32_t g_settingsAssetId_A;   // @ lbl resolved -32164+11192
    if (assetId == g_settingsAssetId_A) {
        return true;
    }
    extern uint32_t g_settingsAssetId_B;   // @ lbl resolved -32163-32708
    if (assetId == g_settingsAssetId_B) {
        return true;
    }
    extern uint32_t g_settingsAssetId_C;   // @ lbl resolved -32163-32712
    return (assetId == g_settingsAssetId_C);
}

/**
 * creditsSettings::RegisterFields  @ 0x8240C308  |  size: 0x118
 *
 * Slot 21.  Registers 8 serialisable float/value fields of the credits
 * display settings (scroll speed, timing params, colour values, etc.)
 * plus one string field — all laid out sequentially from +16 to +44.
 *
 * The schema descriptor is a shared one (@ lbl_825CAF94).
 */
void creditsSettings::RegisterFields() {
    extern const void* g_creditsSettingsSchema;   // @ lbl_825CAF94

    // Fields are registered at offsets +16 through +44 (8 float fields + 1 string)
    // game_8F58 signature: (obj, schema, fieldPtr, desc, flags)
    extern const char* k_scrollSpeed;   // 25936
    extern const char* k_fadeInTime;    // 25948
    extern const char* k_fadeOutTime;   // 25964
    extern const char* k_holdTime;      // 25980
    extern const char* k_textScale;     // 25996
    extern const char* k_lineSpacing;   // 26008
    extern const char* k_pageSpacing;   // 26016
    extern const char* k_colourField;   // 26032 (with different schema @ -20592)

    RegisterSerializedField(this, k_scrollSpeed,  (uint8_t*)this + 16, &g_creditsSettingsSchema, 0);
    RegisterSerializedField(this, k_fadeInTime,   (uint8_t*)this + 20, &g_creditsSettingsSchema, 0);
    RegisterSerializedField(this, k_fadeOutTime,  (uint8_t*)this + 24, &g_creditsSettingsSchema, 0);
    RegisterSerializedField(this, k_holdTime,     (uint8_t*)this + 28, &g_creditsSettingsSchema, 0);
    RegisterSerializedField(this, k_textScale,    (uint8_t*)this + 32, &g_creditsSettingsSchema, 0);
    RegisterSerializedField(this, k_lineSpacing,  (uint8_t*)this + 36, &g_creditsSettingsSchema, 0);
    RegisterSerializedField(this, k_pageSpacing,  (uint8_t*)this + 40, &g_creditsSettingsSchema, 0);

    extern const void* g_creditsColourSchema;   // @ lbl_825CAF9C (-20592)
    RegisterSerializedField(this, k_colourField,  (uint8_t*)this + 44, &g_creditsColourSchema,   0);
}

// ─────────────────────────────────────────────────────────────────────────────
// pongCreditsContext  [vtable @ 0x8205EE04 / secondary @ 0x8205EE6C]
// ─────────────────────────────────────────────────────────────────────────────

/**
 * pongCreditsContext::~pongCreditsContext  @ 0x82309C38  |  size: 0x68
 *
 * Destructor.  Resets both vtable pointers (primary and the embedded
 * secondary-base vtable at +0x14) to their base-class values, clears
 * the page-group pointer, then conditionally frees via rage_free.
 *
 * The secondary vtable at this+0x14 belongs to the embedded MI base
 * (the inner hsmContext object); its pointer is reset to the base
 * class's thunk table @ lbl_8202.... before the primary vtable is
 * written.
 */
pongCreditsContext::~pongCreditsContext() {
    // Restore secondary (MI-base) vtable @ this+0x14
    // vtable ptr = lbl computed from lis -32254 + 31540 (0x82027B34 area)
    // Clear page-group pointer @ this+0x18
    *(uint32_t*)((uint8_t*)this + 24) = 0;
    // Restore primary vtable @ this+0x00
    // vtable ptr = lbl computed from lis -32254 + 30404 (0x820276C4 area)
    // vtable managed by C++ runtime

    // conditional free handled by caller
}

/**
 * pongCreditsContext_rtti_EE6C_0  @ 0x82309CA0
 *
 * MI-base thunk destructor.  The secondary vtable slot 0 adjusts `this`
 * by -20 bytes to recover the true `this` pointer before delegating to
 * the primary destructor.  This is the standard Itanium ABI "in-charge"
 * destructor thunk for a non-primary base.
 */
/**
 * pongCreditsContext::CanTransition  @ 0x82309D38  |  size: 0x28
 *
 * Slot 11.  Checks whether the credits context is ready to allow
 * an HSM state transition.  If the page group exists, notifies
 * atSingleton (likely clearing a pending request flag), then
 * always returns true (credits context never blocks transitions).
 */
bool pongCreditsContext::CanTransition() {
    if (m_pPageGroup != nullptr) {
        atSingleton_F728_g(m_pPageGroup);
    }
    return true;
}

/**
 * pongCreditsContext::OnEnterCredits  @ 0x82309E18  |  size: 0x120
 *
 * Slot 16.  Called when the HSM transitions into the credits state.
 * Checks whether we are NOT on the main thread (via HSM manager flag
 * at +495 and game settings flag at +24), then if so:
 *   1. Notifies the page group to start its presentation (slot 2 call).
 *   2. Decides whether to play a background movie or just transition
 *      to state 6 (the credits roll) via hsmContext_SetNextState.
 *   3. Queues a util_94B8 call with the current context data.
 *
 * If no page group or not active, falls through silently.
 */
void pongCreditsContext::OnEnterCredits() {
    // Determine if we are off the main thread
    extern uint8_t g_hsmMgr_flags[];   // @ lbl_8271A81C area, byte +495
    extern void*   g_gameSettings;     // @ lbl_8271A740 area, byte +24
    bool offMainThread = (g_hsmMgr_flags[495] != 0);
    if (!offMainThread) {
        bool gameSettingsActive = (*(uint8_t*)((uint8_t*)g_gameSettings + 24) != 0);
        offMainThread = gameSettingsActive;
    }

    if (!offMainThread) {
        // Main-thread path: nothing to do
        return;
    }

    if (m_pPageGroup == nullptr) {
        return;
    }

    // Notify page group to open/present
    pg_0890_g(m_pPageGroup);
    m_pPageGroup->Open();   // vtable slot 2

    // Check page group active state (+152) and m_bActive (+28)
    bool pageActive = (*(uint8_t*)((uint8_t*)m_pPageGroup + 152) != 0);
    bool selfActive = (m_bActive != 0);
    if (!pageActive && !selfActive) {
        return;
    }

    // Transition to state 6 (credits roll)
    extern void* g_hsmContextPtr;   // @ lbl_8271A81C
    hsmContext_SetNextState_2800(g_hsmContextPtr, 6 /*STATE_CREDITS_ROLL*/);

    // Check if the global movie record has valid frame range
    extern void* g_movieRecord;   // @ lbl_8271A320
    bool hasValidRange = !((*(int32_t*)((uint8_t*)g_movieRecord + 16) == -1) &&
                           (*(int32_t*)((uint8_t*)g_movieRecord + 20) == -1));
    if (!hasValidRange) {
        return;
    }

    // Queue credits context data
    extern void* g_creditsContextData;   // @ lbl_8258C000 area (-24384)
    util_94B8(/*r4=*/2, /*r5=*/1, /*r6=*/g_creditsContextData, /*r7=*/0,
              g_creditsContextData, g_creditsContextData);
}

/**
 * pongCreditsContext::OnExitCredits  @ 0x82309F38  |  size: 0x88
 *
 * Slot 18.  Called when leaving the credits HSM context.
 * Checks the same main-thread gate, then if off-thread and page group
 * is valid, calls pg_6000_g to dismiss the UI and calls slot 6 on
 * the page group (Close/Hide).
 */
void pongCreditsContext::OnExitCredits() {
    extern uint8_t g_hsmMgr_flags[];
    extern void*   g_gameSettings;
    bool offMainThread = (g_hsmMgr_flags[495] != 0);
    if (!offMainThread) {
        bool gameSettingsActive = (*(uint8_t*)((uint8_t*)g_gameSettings + 24) != 0);
        offMainThread = gameSettingsActive;
    }

    if (!offMainThread) {
        return;
    }

    // Dismiss the UI via the global UI manager
    extern void* g_uiManagerPtr;   // @ lbl_8271A81C
    pg_6000_g(g_uiManagerPtr);

    if (m_pPageGroup == nullptr) {
        return;
    }

    m_pPageGroup->Close();   // vtable slot 6
}

/**
 * pongCreditsContext::RegisterWithCreditsRoll  @ 0x82309CA0  |  size: 0x94
 *
 * Slot 23.  Allocates and initialises the UI page group for the credits roll,
 * then registers this context with the credits roll manager.
 *
 * Steps:
 *   1. Calls xe_main_thread_init_0038 to assert we're on the main thread.
 *   2. Allocates a 220-byte page group object from the main thread allocator
 *      (via vtable slot 1 of the SDA-resident allocator table).
 *   3. If allocation succeeds, calls InitializePageGroup to construct the page group.
 *   4. Stores the result in m_pPageGroup (this+24).
 *   5. Calls rage_ADF8 to bind this context to the credits roll system,
 *      passing the credits roll name string and the category tag 202.
 *
 * Debug note: the strings "cfail" / "yreadyfail" are debug log tags
 * passed to the no-op logger (nop_8240E6D0) as bookends; they are
 * harmless in the shipping build.
 */
void pongCreditsContext::RegisterWithCreditsRoll() {
    // Entry debug bookend: "cfail" @ 0x8205ED64
    // nop_8240E6D0("cfail");   // stripped in release

    // Assert main thread is ready
    xe_main_thread_init_0038();

    // Allocate a UI page group (220 bytes, 16-byte aligned).
    // The main allocator table is at SDA offset 0 (base 0x82600000);
    // index [1] (byte offset 4) holds the active allocator pointer.
    // vtable slot 1 on that allocator is Alloc(size, align).
    extern uint32_t g_mainAllocTable;      // @ SDA offset 0 = 0x82600000
    uint32_t* allocTableBase = (uint32_t*)g_mainAllocTable;
    void*     allocator      = (void*)allocTableBase[1];  // [4 bytes in]
    void* pageGroupMem = VCALL_ALLOC(allocator, /*size=*/220, /*align=*/16);

    if (pageGroupMem != nullptr) {
        // Construct the page group object
        /* game_F4C0 call - TODO: fix return type */
    } else {
        pageGroupMem = nullptr;
    }
    m_pPageGroup = (pongPageGroup*)pageGroupMem;

    // Register with the credits-roll manager.
    // g_pCreditsRollObj is a global pointer (SDA offset 25888 @ lbl_82606520)
    // that points to the live credits-roll singleton object; the name string
    // for this context lives at offset +50 within that object.
    extern void* g_pCreditsRollObj;   // @ lbl_82606520 [.data sz:4, SDA +25888]
    const char* nameStr = (const char*)((uint8_t*)g_pCreditsRollObj + 50);
    rage_ADF8(this, /*category=*/202, nameStr);

    // Exit debug bookend: "yreadyfail" @ 0x8205ED80
    // nop_8240E6D0("yreadyfail");   // stripped in release
}




// ─────────────────────────────────────────────────────────────────────────────
// pongCreditsState  [vtable @ 0x8205EE7C]
// ─────────────────────────────────────────────────────────────────────────────

/**
 * pongCreditsState::~pongCreditsState  @ 0x8230A000  |  size: 0x60
 *
 * Destructor.  Resets vtable, delegates to pongAttractState base-class
 * cleanup (Shutdown = the shared attract state teardown), then restores
 * the pongCreditsState vtable before the conditional free.
 */
pongCreditsState::~pongCreditsState() {
    // Reset to pongCreditsState vtable (then base restores its own)
    // vtable managed by C++ runtime

    // Delegate attract-state common cleanup
    pongAttractState_Shutdown(this);

    // Re-install pongCreditsState vtable for destructor finish
    // (base class restored theirs; we re-apply ours, then pongAttractState base)
    // vtable managed by C++ runtime

    // conditional free handled by caller
}

/**
 * pongCreditsState::Init  @ 0x8230A068  |  size: 0x108
 *
 * Slot 14.  Initialises the credits state:
 *   1. Calls the main-thread init stub (xe_main_thread_init_0038).
 *   2. Allocates a new pongCreditsContext via the thread's allocator
 *      (vtable slot 1, requesting 32 bytes at alignment 16).
 *   3. Populates the new context object: sets vtable pointers, zeroes
 *      fields, stores it in m_pContext.
 *   4. Registers the context with the credits-roll manager (slot 23).
 */
void pongCreditsState::Init() {
    xe_main_thread_init_0038();

    // Allocate pongCreditsContext through the thread allocator
    // (SDA[0] is the main allocator table; slot 1 = Alloc(size, align))
    // g_mainAllocTable declared externally   // SDA @ 0x82600000 offset 0
    void* (*allocFn)(void*, uint32_t, uint32_t) = VTABLE_SLOT1(g_mainAllocTable);
    pongCreditsContext* ctx = (pongCreditsContext*)allocFn(g_mainAllocTable, 32, 16);

    if (ctx != nullptr) {
        // Initialise context fields
    // vtable managed by C++ runtime
    // vtable managed by C++ runtime
        *(uint32_t*)((uint8_t*)ctx + 24)           = 0;  // m_pPageGroup = nullptr
        *(uint8_t*)((uint8_t*)ctx + 28)            = 0;  // m_bActive = false

        // Build the back-pointer entry and register in the attract state arrays
        // (the scaffold's complex r9/r30 code sets up indexed slot storage)
        extern uint32_t g_attractStateCount;         // @ lbl_8261+14436
        uint32_t slotIdx = g_attractStateCount;
        extern uint8_t* g_attractStateFlags;         // @ lbl_8261+14952
        extern uint32_t* g_attractStateSizes;        // @ lbl_8261+14696
        extern pongCreditsContext** g_attractStateCtxPtrs; // @ lbl_8261+14440

        g_attractStateFlags[slotIdx]       = 128;
        g_attractStateSizes[slotIdx]       = 16;
        g_attractStateCtxPtrs[slotIdx]     = ctx;
        g_attractStateCount                = slotIdx + 1;
    } else {
        ctx = nullptr;
    }

    m_pContext = ctx;

    // Register context with credits-roll manager (slot 23 on ctx)
    if (ctx != nullptr) {
        ctx->RegisterWithCreditsRoll();   // vtable slot 23
    }
}

/**
 * pongCreditsState::GetContext  @ 0x82309C28  |  size: 0xC
 *
 * Slot 13.  Returns the static state-descriptor/context-ID for this
 * state type.  Used by the HSM to identify the state kind.
 * Equivalent to the RTTI-based GetStateClass() pattern.
 */
void* pongCreditsState::GetContext() {
    // Returns address of the static state-descriptor @ 0x8205EDB0
    // (embedded within the rdata block starting at lbl_8205ED98)
    return (void*)0x8205EDB0;
}

/**
 * pongCreditsState::OnEnter  @ 0x8230A150  |  size: 0x118
 *
 * Slot 11.  State entry handler.  Called by the HSM with the previous
 * state index.  Actions depend on which state we came from:
 *
 *   prevState == 6  → Coming from attract: clear the roll-visible flag,
 *                     set credits-roll mode to 2, store context ptr.
 *   prevState == 9  → Coming from network screen: set roll-visible flag,
 *                     enable the HSM manager's overlay (byte +576), bump
 *                     the credits-roll entry counter, notify the manager.
 *   prevState == 12 → Immediate return (transient pass-through state).
 *   other           → Post a transition request via PostStateTransitionRequest / nop.
 *
 * Also enables the page group's auto-advance (+85) if present.
 */
void pongCreditsState::OnEnter(int prevStateIdx) {
    pg_E6E0(2053 /*CREDITS_ENTER_MSG*/, 64, 0, 0);

    // Enable auto-advance on the page group if it exists
    if (m_pContext != nullptr && m_pContext->m_pPageGroup != nullptr) {
        *(uint8_t*)((uint8_t*)m_pContext->m_pPageGroup + 85) = 1;
    }

    if (prevStateIdx == 12) {
        // Pass-through: nothing to do
        return;
    }

    if (prevStateIdx == 9) {
        // Coming from network screen — start visible credits roll
        extern void* g_creditsRoll;           // @ lbl_8271A358
        g_creditsRollVisible = 1;

        extern void* g_hsmMgr;               // @ lbl resolved from SDA
        *(uint8_t*)((uint8_t*)g_hsmMgr + 576) = 1;   // enable overlay

        // Add this context to the roll's entry list
        uint32_t newCount = *(uint32_t*)((uint8_t*)g_creditsRoll + 48) + 1;
        *(uint32_t*)((uint8_t*)g_creditsRoll + 48) = newCount;
        uint32_t* slotArray = *(uint32_t**)((uint8_t*)g_creditsRoll + 44);
        slotArray[newCount - 1] = (uint32_t)(uintptr_t)m_pContext;

        // Notify roll of the new count
        game_AD40(g_creditsRoll, newCount);

        pongCreditsState_9D68_h(m_pContext, 0 /*not visible*/);
        return;
    }

    if (prevStateIdx == 6) {
        // Coming from attract: deactivate roll, set mode 2, store context
        g_creditsRollVisible = 0;
        extern void* g_creditsRoll;
        *(uint32_t*)((uint8_t*)g_creditsRoll + 52) = 2;    // mode = 2
        *(uint32_t*)((uint8_t*)g_creditsRoll + 56) = (uint32_t)(uintptr_t)m_pContext;

        pongCreditsState_9D68_h(m_pContext, 0);
        return;
    }

    // Generic previous-state: post a transition request
    void* transReq = PostStateTransitionRequest(m_pHSMContext, prevStateIdx);
    // Notify credits-roll of transition (address of static table entry)
    extern void* g_creditsTransTable;   // @ lbl_8205F2D4 - 4712 area
    nop_8240E6D0(g_creditsTransTable, transReq, prevStateIdx);
}

/**
 * pongCreditsState::OnExit  @ 0x8230A268  |  size: 0x90
 *
 * Slot 12.  State exit handler.  Called with the next state index.
 *
 *   nextState == 6  → Set credits-roll mode to 3 (leaving via attract).
 *   nextState == 12 → Immediate return.
 *   other           → Post transition via PostStateTransitionRequest / nop.
 *
 * Disables page group auto-advance on exit.
 */
void pongCreditsState::OnExit(int nextStateIdx) {
    pg_E6E0(2054 /*CREDITS_EXIT_MSG*/, 64, 0, 0);

    // Disable auto-advance on the page group
    if (m_pContext != nullptr && m_pContext->m_pPageGroup != nullptr) {
        *(uint8_t*)((uint8_t*)m_pContext->m_pPageGroup + 85) = 0;
    }

    if (nextStateIdx == 6) {
        // Leaving to attract: mode 3
        extern void* g_creditsRoll;
        *(uint32_t*)((uint8_t*)g_creditsRoll + 52) = 3;
        return;
    }

    if (nextStateIdx == 12) {
        return;
    }

    // Generic next-state: post a transition request
    void* transReq = PostStateTransitionRequest(m_pHSMContext, nextStateIdx);
    extern void* g_creditsExitTable;   // @ lbl_8205F2D4 - 4660 area
    nop_8240E6D0(g_creditsExitTable, transReq, nextStateIdx);
}

/**
 * pongCreditsState_9D68_h  @ 0x82309D68  |  size: ~0x80
 *
 * Helper shared between pongCreditsContext::CanTransition and
 * pongCreditsState::OnEnter.
 *
 * Sets the credits-context display mode:
 *   If visible == 0: calls pg_61E8_g on the UI manager with fade params,
 *                    fading from 2.0f over 2 seconds.
 * In both cases, if the page group is valid, writes visible to its
 * state byte (+155) and calls slot 5 (SetVisible/Refresh), then
 * clears the m_bActive flag on the credits state.
 */
void pongCreditsState_9D68_h(pongCreditsContext* ctx, uint8_t visible) {
    if (visible == 0) {
        extern void* g_uiManagerPtr;   // @ lbl_8271A81C
        extern float g_fadeTime;       // @ lbl_8253C000 - 12016 (e.g. 2.0f)
        pg_61E8_g(g_uiManagerPtr, 2 /*type*/, 1 /*mode*/, g_fadeTime, 0.0f);
    }

    if (ctx->m_pPageGroup != nullptr) {
        *(uint8_t*)((uint8_t*)ctx->m_pPageGroup + 155) = visible;
        ctx->m_pPageGroup->SetVisible();   // vtable slot 5

        // Clear m_bActive on the outer state (the caller, accessed via ctx+28
        // in the scaffold — this is the context's own m_bActive flag)
        ctx->m_bActive = 0;
    } else {
        ctx->m_bActive = 0;
    }
}


// ═══════════════════════════════════════════════════════════════════════════════
// pongLegalsContext  [vtable @ 0x8205F8FC]
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * pongLegalsContext::~pongLegalsContext  @ 0x82310ED0  |  size: 0x8C
 *
 * Destructor.  If a page-group sub-object exists at +0x14, destroys it
 * via its virtual destructor (slot 0 with shouldFree=1), then resets
 * the primary vtable to the base class and conditionally frees self.
 */
pongLegalsContext::~pongLegalsContext() {
    // Install pongLegalsContext vtable (for correct dtor dispatch)
    // vtable @ 0x8205F8FC

    // Destroy page group sub-object if present
    if (m_pPageGroup != nullptr) {
        // VCALL slot 0 (destructor) with shouldFree = 1
        typedef void (*DtorFn)(void*, bool);
        DtorFn dtor = *(DtorFn*)(*(uint32_t*)m_pPageGroup);
        dtor(m_pPageGroup, true);
        m_pPageGroup = nullptr;
    }

    // Restore base class vtable @ 0x820276C4
    // (base class does its own cleanup)

    // conditional free handled by caller
}

/**
 * pongLegalsContext::CanTransition  @ 0x82310F60  |  size: 0x54
 *
 * Slot 12.  Destroys the page-group sub-object (if any) and returns
 * true, allowing the HSM to proceed with the transition.
 */
bool pongLegalsContext::CanTransition() {
    if (m_pPageGroup != nullptr) {
        // Destroy via virtual dtor with shouldFree=1
        typedef void (*DtorFn)(void*, bool);
        DtorFn dtor = *(DtorFn*)(*(uint32_t*)m_pPageGroup);
        dtor(m_pPageGroup, true);
        m_pPageGroup = nullptr;
    }
    return true;
}

/**
 * pongLegalsContext_InputPoll  @ 0x82311098  |  size: 0x104
 *
 * Helper called by Update().  Polls all 4 controller ports for any
 * button input.  If any button is pressed on any controller, performs
 * additional state checks (loads page group, queries button state,
 * looks up "SAVING" string, and notifies the page group).
 * Sets m_bInputDetected to 1 when input is found.
 *
 * The input check examines three byte-string regions per controller
 * at offsets +8, +16, and +48 from each controller's 808-byte record.
 */
static void pongLegalsContext_InputPoll(pongLegalsContext* ctx) {
    if (ctx->m_bInputDetected != 0) {
        return;  // Already detected input
    }

    // Controller array base: loaded from g_loop_obj_ptr (+808 offset)
    extern uint32_t g_controllerArrayBase;   // @ 0x8271A31C → load → +808
    uint32_t* controllerBase = (uint32_t*)(*(uint32_t*)(&g_controllerArrayBase) + 808);

    for (int i = 0; i < 4; ++i) {
        uint32_t controllerAddr = controllerBase[i * (808 / 4)];
        // Check three button regions at +8, +16, +48
        bool btn1 = pg_FFF8_g((uint8_t*)controllerAddr + 8);
        if (btn1) goto input_found;

        bool btn2 = pg_FFF8_g((uint8_t*)controllerAddr + 16);
        if (btn2) goto input_found;

        bool btn3 = pg_FFF8_g((uint8_t*)controllerAddr + 48);
        if (btn3) goto input_found;
    }
    return;  // No input detected on any controller

input_found:
    {
        void* pageGroup = ctx->m_pPageGroup;
        uint8_t buttonState = SinglesNetworkClient_B2A8_g(pageGroup);

        // Check HSM manager's context pointer (+556)
        extern void* g_hsmMgrPtr;   // @ 0x825EAB30 (g_loop_obj_ptr)
        void* hsmMgr = *(void**)(*(uint32_t*)&g_hsmMgrPtr + (-21712 & 0xFFFF));
        // TODO: verify — complex HSM manager field check at +556 and flag at 0x826065EB

        // Look up "SAVING" in the page group's text table
        extern const char* k_SAVING;   // @ 0x8205DFB0
        void* textEntry = SinglesNetworkClient_9318_g(
            *(uint32_t*)((uint8_t*)pageGroup + 92), k_SAVING);

        uint32_t savingState = 1;
        if (textEntry != nullptr) {
            *(uint32_t*)textEntry = 1;
            *(uint32_t*)((uint8_t*)textEntry + 4) = 3;
        }

        if ((buttonState & 0xFF) != 0) {
            SinglesNetworkClient_B320_g(pageGroup);
        }

        ctx->m_bInputDetected = 1;
    }
}

/**
 * pongLegalsContext::Update  @ 0x82310FB8  |  size: 0xB4
 *
 * Slot 16.  Main update for the legals screen.  If the page group exists:
 *   1. Polls all controllers for input via the InputPoll helper.
 *   2. Calls the page group's Update (vtable slot 2).
 *   3. Checks whether the user pressed a button (via B2A8 / B1E8).
 *   4. Looks for a "SAVING" text entry; if found and has positive value,
 *      transitions to state 6 (attract/main menu).
 */
void pongLegalsContext::Update() {
    if (m_pPageGroup == nullptr) {
        return;
    }

    // Poll all controllers for input
    pongLegalsContext_InputPoll(this);

    // Call page group Update (vtable slot 2)
    typedef void (*UpdateFn)(void*);
    UpdateFn updateFn = (UpdateFn)(*(uint32_t*)(*(uint32_t*)m_pPageGroup + 8));
    updateFn(m_pPageGroup);

    // Now working with the page group directly
    void* pg = m_pPageGroup;
    int32_t resultValue = 0;

    // Check button state
    uint8_t buttonState = SinglesNetworkClient_B2A8_g(pg);

    // Process input
    SinglesNetworkClient_B1E8_g(pg);

    // Look up "SAVING" string in page group
    extern const char* k_SAVING;   // @ 0x8205DFB8
    void* savingEntry = SinglesNetworkClient_9280_g(pg, k_SAVING);
    if (savingEntry != nullptr) {
        resultValue = SinglesNetworkClient_A5C8_g(savingEntry);
    }

    // If button was pressed, notify
    if ((buttonState & 0xFF) != 0) {
        SinglesNetworkClient_B320_g(pg);
    }

    // If saving entry had a positive value, transition to state 6
    if (resultValue > 0) {
        extern void* g_hsmContextPtr;   // @ loaded from 0x825EAB30
        hsmContext_SetNextState_2800(g_hsmContextPtr, 6);
    }
}

/**
 * pongLegalsContext::OnExit  @ 0x82311070  |  size: 0x24
 *
 * Slot 18.  If the page group exists, forwards to its vtable slot 6
 * (Close/Hide) as a tail call.
 */
void pongLegalsContext::OnExit() {
    if (m_pPageGroup == nullptr) {
        return;
    }
    // VCALL slot 6 (byte offset 24) on page group — Close/Hide
    typedef void (*CloseFn)(void*);
    CloseFn closeFn = (CloseFn)(*(uint32_t*)(*(uint32_t*)m_pPageGroup + 24));
    closeFn(m_pPageGroup);
}


// ═══════════════════════════════════════════════════════════════════════════════
// pongLegalsState  [vtable @ 0x8205F964]
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * pongLegalsState::GetContext  @ 0x82310EC0  |  size: 0xC
 *
 * Slot 13.  Returns the static state descriptor used by the HSM to
 * identify this state type.
 */
void* pongLegalsState::GetContext() {
    return (void*)0x8205F854;   // static descriptor in .rdata
}

/**
 * pongLegalsState::Init  @ 0x823111A8  |  size: 0xD0
 *
 * Slot 14.  Initialises the legals state:
 *   1. Allocates a pongLegalsContext (28 bytes, 16-byte aligned).
 *   2. Zeros all fields, sets its vtable to 0x8205F8FC.
 *   3. Stores the context in m_pContext (this+8).
 *   4. Allocates a 240-byte page group sub-object via game_9358.
 *   5. Stores the page group in the context's m_pPageGroup (+20).
 *   6. Calls SinglesNetworkClient_9510_g to register.
 */
void pongLegalsState::Init() {
    xe_main_thread_init_0038();

    // Allocate pongLegalsContext (28 bytes, 16-byte aligned)
    // g_mainAllocTable declared externally   // SDA @ 0x82600000
    uint32_t* allocBase = (uint32_t*)*(uint32_t*)&g_mainAllocTable;
    void* allocator = (void*)allocBase[1];   // [+4 = allocator pointer]
    void* ctxMem = VCALL_ALLOC(allocator, /*size=*/28, /*align=*/16);

    pongLegalsContext* ctx = nullptr;
    if (ctxMem != nullptr) {
        ctx = (pongLegalsContext*)ctxMem;
        // Zero all fields
        ctx->m_baseData[0] = 0;   // +0x04
        ctx->m_baseData[1] = 0;   // +0x08
        ctx->m_baseData[2] = 0;   // +0x0C
        ctx->m_baseData[3] = 0;   // +0x10
        ctx->m_pPageGroup = nullptr;       // +0x14
        ctx->m_bInputDetected = 0;         // +0x18
        // Set vtable to pongLegalsContext @ 0x8205F8FC
    }

    m_pContext = ctx;

    // Debug log
    nop_8240E6D0("pongLegalsState::Init - context");   // @ 0x8205F864

    // Allocate page-group sub-object (240 bytes, 16-byte aligned)
    xe_main_thread_init_0038();
    allocBase = (uint32_t*)*(uint32_t*)&g_mainAllocTable;
    allocator = (void*)allocBase[1];
    void* pgMem = VCALL_ALLOC(allocator, /*size=*/240, /*align=*/16);

    void* pageGroup = nullptr;
    if (pgMem != nullptr) {
        pageGroup = game_9358(pgMem);   // construct page group
    }

    // Store page group in context (+20)
    if (ctx != nullptr) {
        ctx->m_pPageGroup = pageGroup;
    }

    // Register with the state manager
    SinglesNetworkClient_9510_g(pageGroup);

    nop_8240E6D0("pongLegalsState::Init - done");   // @ 0x8205F880
}

/**
 * pongLegalsState::OnEnter  @ 0x82311280  |  size: 0xD0
 *
 * Slot 11.  State entry handler.
 *
 *   prevState == 3  → Coming from boot/logos: check HSM context for
 *                     active session, set up notification, clear context
 *                     active flag, show legals page group, set credits
 *                     roll mode = 2 and store context.
 *   other           → Generic: post transition via PostStateTransitionRequest.
 */
void pongLegalsState::OnEnter(int prevStateIdx) {
    if (prevStateIdx != 3) {
        // Generic previous state: post a transition request
        void* transReq = PostStateTransitionRequest(m_pHSMContext, prevStateIdx);
        nop_8240E6D0("pongLegalsState::OnEnter generic", transReq, prevStateIdx);
        return;
    }

    // Coming from state 3 (logos)
    // Check HSM manager session context
    extern void* g_hsmMgrPtr;   // loaded from 0x825EAB30
    void* hsmMgr = *(void**)((uint8_t*)g_hsmMgrPtr + (-21712 & 0xFFFF));
    // TODO: verify exact address computation
    void* sessionCtx = *(void**)((uint8_t*)hsmMgr + 556);

    if (sessionCtx != nullptr) {
        uint8_t sessionActive = *(uint8_t*)((uint8_t*)sessionCtx + 4);
        if (sessionActive == 0) {
            // Set up notification: struct on stack {0, vtable_ptr, 1, 0}
            // Calls pg_0708_g to queue HSM notification
            // @ 0x82300000 area vtable for notification
            pg_0708_g(sessionCtx);
        }
    }

    // Access context
    pongLegalsContext* ctx = m_pContext;

    // Clear input-detected flag
    ctx->m_bInputDetected = 0;

    // If page group exists, call SetVisible (vtable slot 5)
    if (ctx->m_pPageGroup != nullptr) {
        typedef void (*SetVisibleFn)(void*);
        SetVisibleFn fn = (SetVisibleFn)(*(uint32_t*)(*(uint32_t*)ctx->m_pPageGroup + 20));
        fn(ctx->m_pPageGroup);
    }

    // Set credits roll mode = 2 and store context pointer
    extern void* g_creditsRoll;   // @ 0x8271A358
    *(uint32_t*)((uint8_t*)g_creditsRoll + 52) = 2;
    *(uint32_t*)((uint8_t*)g_creditsRoll + 56) = (uint32_t)(uintptr_t)m_pContext;
}

/**
 * pongLegalsState::OnExit  @ 0x82311368  |  size: 0x54
 *
 * Slot 12.  State exit handler.
 *
 *   nextState == 6  → Leaving to attract/frontend: call game_AAF8
 *                     on the credits roll with (0, 0).
 *   other           → Post transition via PostStateTransitionRequest + log.
 */
void pongLegalsState::OnExit(int nextStateIdx) {
    if (nextStateIdx != 6) {
        // Generic next state
        void* transReq = PostStateTransitionRequest(m_pHSMContext, nextStateIdx);
        nop_8240E6D0("pongLegalsState::OnExit generic", transReq, nextStateIdx);
        return;
    }

    // Leaving to state 6 (attract)
    extern void* g_creditsRoll;   // @ 0x8271A358
    game_AAF8(g_creditsRoll, 0, 0);
}


// ═══════════════════════════════════════════════════════════════════════════════
// pongDialogContext  [vtable @ 0x8205F31C / secondary @ 0x8205F384]
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * pongDialogContext::~pongDialogContext  @ 0x8230C7A0  |  size: 0x68
 *
 * Destructor.  Resets the secondary vtable at +0x14 to the derived
 * value (0x8205F384), clears the page-group pointer, then restores
 * both vtable pointers to their base-class values before optionally
 * freeing the object.
 */
pongDialogContext::~pongDialogContext() {
    // Set derived secondary vtable at +0x14
    // Clear page-group pointer
    *(uint32_t*)((uint8_t*)this + 24) = 0;
    // Restore base secondary vtable
    // Restore base primary vtable
    // vtable managed by C++ runtime

    // conditional free handled by caller
}

/**
 * pongDialogContext_secondaryBase_dtor  (MI thunk)  @ 0x8230CF70
 *
 * The secondary vtable slot 0 adjusts `this` by -20 bytes to recover
 * the true `this` pointer, then delegates to the primary destructor.
 */
static void pongDialogContext_secondaryBase_dtor(void* base, bool shouldFree) {
    pongDialogContext* self = (pongDialogContext*)((uint8_t*)base - 20);
    self->~pongDialogContext(shouldFree);
}

/**
 * pongDialogContext::Register  @ 0x8230C808  |  size: 0x94
 *
 * Slot 23.  Allocates and initialises the dialog page group (1508 bytes),
 * then registers this context with the dialog system.
 *
 * Steps:
 *   1. Asserts main thread via xe_main_thread_init_0038.
 *   2. Allocates 1508 bytes (16-byte aligned) from the main allocator.
 *   3. Constructs the page group via game_1620.
 *   4. Stores the result in m_pPageGroup (+24).
 *   5. Loads the dialog manager name from g_pDialogRollObj (+50).
 *   6. Registers this context via rage_ADF8 with category 204.
 *   7. Stores the page group in g_dialogPageGroup global.
 */
void pongDialogContext::Register() {
    nop_8240E6D0("pongDialogContext::Register enter");   // @ 0x8205F240

    xe_main_thread_init_0038();

    // Allocate dialog page group (1508 bytes, 16-byte aligned)
    // g_mainAllocTable declared externally   // SDA @ 0x82600000
    uint32_t* allocBase = (uint32_t*)*(uint32_t*)&g_mainAllocTable;
    void* allocator = (void*)allocBase[1];
    void* pgMem = VCALL_ALLOC(allocator, /*size=*/1508, /*align=*/16);

    void* pageGroup = nullptr;
    if (pgMem != nullptr) {
        pageGroup = game_1620(pgMem);   // construct dialog page group
    }
    m_pPageGroup = pageGroup;

    // Register with the dialog manager
    extern void* g_pDialogRollObj;   // @ 0x82606514  [.data, 4 bytes]
    const char* nameStr = (const char*)((uint8_t*)g_pDialogRollObj + 50);
    rage_ADF8(this, /*category=*/204, nameStr);

    // Store page group in global
    extern void* g_dialogPageGroup;   // @ 0x82606628  [.data, 4 bytes]
    g_dialogPageGroup = m_pPageGroup;

    nop_8240E6D0("pongDialogContext::Register done");   // @ 0x8205F258
}

/**
 * pongDialogContext::Update  @ 0x8230C8A8  |  size: 0x70
 *
 * Slot 16.  Checks whether the dialog is ready to advance.
 * If the page group exists:
 *   1. Calls Open (vtable slot 2) on the page group.
 *   2. Calls SinglesNetworkClient_2470_g to check if dialog completed.
 *   3. If completed, transitions to m_nextStateIdx via the HSM manager.
 */
void pongDialogContext::Update() {
    if (m_pPageGroup == nullptr) {
        return;
    }

    // Open/present the dialog page group (vtable slot 2)
    typedef void (*OpenFn)(void*);
    OpenFn openFn = (OpenFn)(*(uint32_t*)(*(uint32_t*)m_pPageGroup + 8));
    openFn(m_pPageGroup);

    // Check if the dialog has finished
    uint8_t isReady = SinglesNetworkClient_2470_g(m_pPageGroup);
    if ((isReady & 0xFF) == 0) {
        return;   // Not yet ready
    }

    // Transition to the stored next state
    extern void* g_hsmContextPtr;   // loaded from 0x825EAB30 area
    hsmContext_SetNextState_2800(g_hsmContextPtr, m_nextStateIdx);
}

/**
 * pongDialogContext::OnExit  @ 0x8230C918  |  size: 0x5C
 *
 * Slot 18.  Called when leaving the dialog context.
 * If the page group exists:
 *   - If m_bSkipClose is set: just clear the flag (don't close).
 *   - Otherwise: call Close (vtable slot 6) on the page group, then clear flag.
 * If no page group: just clear the skip-close flag.
 */
void pongDialogContext::OnExit() {
    if (m_pPageGroup != nullptr) {
        if (m_bSkipClose != 0) {
            // Suppress close — just clear the flag
            m_bSkipClose = 0;
            return;
        }
        // Call Close (vtable slot 6) on the page group
        typedef void (*CloseFn)(void*);
        CloseFn closeFn = (CloseFn)(*(uint32_t*)(*(uint32_t*)m_pPageGroup + 24));
        closeFn(m_pPageGroup);
        m_bSkipClose = 0;
        return;
    }

    m_bSkipClose = 0;
}


// ═══════════════════════════════════════════════════════════════════════════════
// pongDialogState  [vtable @ 0x8205F2D4]
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * pongDialogState::~pongDialogState  @ 0x8230CC20  |  size: 0x68
 *
 * Destructor.  Sets the derived vtable, calls Teardown() to destroy
 * the dialog context, restores the base vtable, then conditionally
 * frees the object.
 */
pongDialogState::~pongDialogState() {
    // Install pongDialogState vtable @ 0x8205F2D4
    // vtable managed by C++ runtime

    // Destroy context via Teardown
    Teardown();

    // Restore base vtable @ 0x820276C4
    // vtable managed by C++ runtime

    // conditional free handled by caller
}

/**
 * pongDialogState::ProcessInput  @ 0x8230CC88  |  size: 0x18
 *
 * Slot 7.  Forwards to the dialog context's sub-object vtable slot 4
 * (ProcessInput/Update on the dialog UI) with r4=0.
 */
void pongDialogState::ProcessInput() {
    void* ctx = *(void**)((uint8_t*)this + 12);   // m_pContext
    // Tail call: context's vtable slot 4 (byte +16)
    typedef void (*ProcessFn)(void*, int);
    ProcessFn fn = (ProcessFn)(*(uint32_t*)(*(uint32_t*)ctx + 16));
    fn(ctx, 0);
}

/**
 * pongDialogState::Teardown  @ 0x8230CD60  |  size: 0x58
 *
 * Slot 8.  Tears down the dialog context:
 *   1. If m_pContext is non-null, calls its vtable slot 5 (Shutdown).
 *   2. Then calls the context's destructor with shouldFree=1.
 *   3. Nulls out m_pContext.
 */
void pongDialogState::Teardown() {
    if (m_pContext == nullptr) {
        return;
    }

    // Call Shutdown (vtable slot 5) on the context
    typedef void (*ShutdownFn)(void*);
    ShutdownFn shutdownFn = (ShutdownFn)(*(uint32_t*)(*(uint32_t*)m_pContext + 20));
    shutdownFn(m_pContext);

    // Destroy context with shouldFree=1
    if (m_pContext != nullptr) {
        typedef void (*DtorFn)(void*, bool);
        DtorFn dtor = *(DtorFn*)(*(uint32_t*)m_pContext);
        dtor(m_pContext, true);
    }

    m_pContext = nullptr;
}

/**
 * pongDialogState::GetContext  @ 0x8230C790  |  size: 0xC
 *
 * Slot 13.  Returns the static state descriptor for dialog states.
 */
void* pongDialogState::GetContext() {
    return (void*)0x8205F230;   // static descriptor in .rdata
}

/**
 * pongDialogState::Init  @ 0x8230CCA0  |  size: 0x98
 *
 * Slot 14.  Initialises the dialog state:
 *   1. Allocates a pongDialogContext (36 bytes, 16-byte aligned).
 *   2. Zeros all fields, sets up MI vtable pointers.
 *   3. Sets m_nextStateIdx to -1 (no pending transition).
 *   4. Stores the context in m_pContext (this+12).
 *   5. Calls the context's Register (slot 23) to set up the page group.
 */
void pongDialogState::Init() {
    xe_main_thread_init_0038();

    // Allocate pongDialogContext (36 bytes, 16-byte aligned)
    // g_mainAllocTable declared externally
    uint32_t* allocBase = (uint32_t*)*(uint32_t*)&g_mainAllocTable;
    void* allocator = (void*)allocBase[1];
    void* ctxMem = VCALL_ALLOC(allocator, /*size=*/36, /*align=*/16);

    pongDialogContext* ctx = nullptr;
    if (ctxMem != nullptr) {
        ctx = (pongDialogContext*)ctxMem;
        // Zero base class fields
        // Set MI vtable pointers
        *(void**)((uint8_t*)ctx + 20) = (void*)0x8205F384;   // secondary vtable
        *(void**)ctx = (void*)0x8205F31C;                     // primary vtable (overwrites secondary init)
        // Note: secondary was written then overwritten by primary — PPC instruction scheduling
        // The final state has: +0 = 0x8205F31C, +20 = 0x8205F384
        *(void**)((uint8_t*)ctx + 20) = (void*)0x8205F384;   // re-apply secondary
        // Init fields
        ctx->m_pPageGroup = nullptr;         // +0x18
        ctx->m_nextStateIdx = -1;            // +0x1C
        ctx->m_bSkipClose = 0;               // +0x20
    }

    m_pContext = ctx;

    // Register the context (calls slot 23 → allocates page group)
    if (m_pContext != nullptr) {
        m_pContext->Register();
    }
}

/**
 * pongDialogState::OnEnter  @ 0x8230CDD0  |  size: 0x100
 *
 * Slot 11.  State entry handler.  Actions depend on the previous state:
 *
 *   prevState in [5..11] or 13 → "Dialog states": saves the current HSM
 *       overlay flag, forces it to 1, stores prevStateIdx in the context's
 *       m_nextStateIdx, and adds the context to the credits-roll entry list.
 *       If overlay was previously off, calls SetVisible on the page group
 *       and sets m_bSkipClose.
 *
 *   other → Generic: posts a transition request via PostStateTransitionRequest.
 */
void pongDialogState::OnEnter(int prevStateIdx) {
    pg_E6E0(2051 /*DIALOG_ENTER_MSG*/, 64, 0, 0);

    // Save and set HSM overlay flag
    extern void* g_hsmMgrPtr;   // loaded from address computation
    void* hsmMgr = *(void**)&g_hsmMgrPtr;   // TODO: verify exact load path
    uint8_t prevOverlay = *(uint8_t*)((uint8_t*)hsmMgr + 493);
    m_savedOverlay = prevOverlay;
    if (prevOverlay == 0) {
        *(uint8_t*)((uint8_t*)hsmMgr + 493) = 1;
    }

    // Store prevStateIdx in context's m_nextStateIdx
    if (m_pContext != nullptr) {
        m_pContext->m_nextStateIdx = prevStateIdx;
    }

    // Check if this is a dialog-type state (5..11 or 13)
    bool isDialogState = (prevStateIdx >= 5 && prevStateIdx <= 11) ||
                         (prevStateIdx == 13);

    if (isDialogState) {
        // Add this context to the credits-roll entry list
        extern void* g_creditsRoll;   // @ 0x8271A358
        uint32_t count = *(uint32_t*)((uint8_t*)g_creditsRoll + 48);
        count += 1;
        *(uint32_t*)((uint8_t*)g_creditsRoll + 48) = count;
        uint32_t* entryArray = *(uint32_t**)((uint8_t*)g_creditsRoll + 44);
        entryArray[count - 1] = (uint32_t)(uintptr_t)m_pContext;

        // Notify of new count
        game_AD40(g_creditsRoll, count);

        // If overlay was not previously set, show the page group
        if (m_savedOverlay == 0) {
            pongDialogContext* ctx = m_pContext;
            if (ctx->m_pPageGroup != nullptr) {
                // Call SetVisible (vtable slot 5)
                typedef void (*SetVisibleFn)(void*);
                SetVisibleFn fn = (SetVisibleFn)(*(uint32_t*)(*(uint32_t*)ctx->m_pPageGroup + 20));
                fn(ctx->m_pPageGroup);
            }
            ctx->m_bSkipClose = 1;
        }
        return;
    }

    // Generic previous state: post transition
    void* transReq = PostStateTransitionRequest(m_pHSMContext, prevStateIdx);
    nop_8240E6D0("pongDialogState::OnEnter generic", transReq, prevStateIdx);
}

/**
 * pongDialogState::OnExit  @ 0x8230CED0  |  size: 0x9C
 *
 * Slot 12.  State exit handler.
 *   - Posts DIALOG_EXIT_MSG.
 *   - If saved overlay was 0, restores HSM overlay to 0.
 *   - If nextState in [5..11] or 13: calls game_AAF8 on credits roll.
 *   - Otherwise: posts generic transition via PostStateTransitionRequest.
 */
void pongDialogState::OnExit(int nextStateIdx) {
    pg_E6E0(2052 /*DIALOG_EXIT_MSG*/, 64, 0, 0);

    // Restore HSM overlay if we changed it
    if (m_savedOverlay == 0) {
        extern void* g_hsmMgrPtr;
        void* hsmMgr = *(void**)&g_hsmMgrPtr;
        *(uint8_t*)((uint8_t*)hsmMgr + 493) = 0;
    }

    // Check if this is a dialog-type state
    bool isDialogState = (nextStateIdx >= 5 && nextStateIdx <= 11) ||
                         (nextStateIdx == 13);

    if (isDialogState) {
        extern void* g_creditsRoll;
        game_AAF8(g_creditsRoll, 0, 0);
        return;
    }

// ─────────────────────────────────────────────────────────────────────────────
// frontendData  [vtable @ 0x820763D4]
// ─────────────────────────────────────────────────────────────────────────────

// External globals for asset ID validation (runtime-initialized .data objects)
extern uint32_t g_frontendAssetId_A;   // @ 0x825C2BBC (.data, 4 bytes)
extern uint32_t g_frontendAssetId_B;   // @ 0x825C803C (.data, 4 bytes)
extern uint32_t g_frontendAssetId_C;   // @ 0x825C8038 (.data, 4 bytes)

// External field registration helper
// Signature: RegisterSerializedField(obj, fieldNameStr, fieldPtr, schemaDesc, flags)
extern void RegisterSerializedField(void* obj, const char* fieldName, void* fieldPtr, 
                      const void* schemaDesc, int flags);   // @ 0x821A8F58

/**
 * frontendData::IsSupported  @ 0x8240BBF0  |  size: 0x48
 *
 * Slot 20.  Returns true if assetId matches any of the three asset-type IDs
 * registered for frontendData.  Used by the asset manager to route loads.
 * 
 * This follows the standard RAGE asset-validation pattern: three global IDs
 * are checked in sequence (primary, secondary, tertiary).  The IDs are
 * runtime-initialized from the asset manifest during engine startup.
 */
bool frontendData::IsSupported(uint32_t assetId) const {
    // Check primary asset ID
    if (assetId == g_frontendAssetId_A) {
        return true;
    }
    
    // Check secondary asset ID
    if (assetId == g_frontendAssetId_B) {
        return true;
    }
    
    // Check tertiary asset ID
    return (assetId == g_frontendAssetId_C);
}

/**
 * frontendData::RegisterFields  @ 0x8240BC38  |  size: 0x64
 *
 * Slot 21.  Registers two serializable fields of this data object with
 * the RAGE data system.  Called during asset load/bind.
 * 
 * Field layout:
 *   +0x10 (16): First field  — registered with schema @ 0x825CAF90
 *   +0x14 (20): Second field — registered with schema @ 0x825CAF94
 * 
 * The field name strings are embedded constants in the .text section
 * (inside phBoundCapsule functions at +0xF0 and +0x114 offsets).  This is
 * a common PowerPC pattern where string literals are placed near the code
 * that references them for better cache locality.
 */
void frontendData::RegisterFields() {
    // Field name strings (embedded in .text section for cache locality)
    extern const char* k_frontendFieldName_1;   // @ 0x82576088 (in phBoundCapsule_5F98_2h + 0xF0)
    extern const char* k_frontendFieldName_2;   // @ 0x825763BC (in phBoundCapsule_62A8 + 0x114)
    
    // Schema descriptors (.data section, runtime-initialized)
    extern const void* g_frontendFieldSchema_1;   // @ 0x825CAF90
    extern const void* g_frontendFieldSchema_2;   // @ 0x825CAF94
    
    // Register first field at offset +16
    // RegisterSerializedField(this, fieldNameStr, &field, &schemaDesc, flags)
    RegisterSerializedField(this, k_frontendFieldName_1, (uint8_t*)this + 16, 
              &g_frontendFieldSchema_1, 0);
    
    // Register second field at offset +20
    RegisterSerializedField(this, k_frontendFieldName_2, (uint8_t*)this + 20, 
              &g_frontendFieldSchema_2, 0);
}

// ─────────────────────────────────────────────────────────────────────────────
// dialogData  [vtable @ 0x82075EBC]
// ─────────────────────────────────────────────────────────────────────────────

/**
 * dialogData::GetKey  @ 0x822EC760  |  size: 0xC
 *
 * Slot 22.  Returns the static key string used to identify this
 * data class in the asset registry.  The string " '%s' (%d)" is
 * a format string used for debug logging of dialog data.
 */
const char* dialogData::GetKey() const {
    // Returns pointer to static format string in .rdata @ 0x8205AFB0
    // String content: " '%s' (%d)"
    static const char* k_key = (const char*)0x8205AFB0;
    return k_key;
}

/**
 * dialogData::IsSupported  @ 0x8240AE68  |  size: 0x48
 *
 * Slot 20.  Returns true if assetId matches any of the three asset-type IDs
 * registered for dialogData (checked against global singleton asset tables).
 * Slot 20 in the vtable — used by the asset manager to route loads.
 */
bool dialogData::IsSupported(uint32_t assetId) const {
    // First global singleton ID check
    extern uint32_t g_dialogAssetId_A;   // @ 0x825C2BCC
    if (assetId == g_dialogAssetId_A) {
        return true;
    }
    
    // Second global ID check
    extern uint32_t g_dialogAssetId_B;   // @ 0x825C803C
    if (assetId == g_dialogAssetId_B) {
        return true;
    }
    
    // Third global ID check
    extern uint32_t g_dialogAssetId_C;   // @ 0x825C8038
    return (assetId == g_dialogAssetId_C);
}

/**
 * dialogData::RegisterFields  @ 0x8240AEB0  |  size: 0x6C
 *
 * Slot 21.  Registers the two serializable fields of this data object with
 * the RAGE data system.  Slot 21 — called during asset load/bind.
 * 
 * Field layout:
 *   +0x10 (16): m_dialogType   — int32, dialog type ID
 *   +0x14 (20): m_buttonCount  — int32, number of buttons
 * 
 * Both fields use the same schema descriptor @ 0x825CAF90.
 */
void dialogData::RegisterFields() {
    // Field name strings (embedded in .rdata section)
    extern const char* k_dialogTypeField;     // @ 0x82075E6C (3 bytes)
    extern const char* k_buttonCountField;    // @ 0x82075E70 (6 bytes)
    
    // Schema descriptor (.data section, runtime-initialized)
    extern const void* g_dialogFieldSchema;   // @ 0x825CAF90
    
    // Register m_dialogType field at offset +16
    // RegisterSerializedField(this, fieldNameStr, &field, &schemaDesc, flags)
    RegisterSerializedField(this, k_dialogTypeField, (uint8_t*)this + 16, 
              &g_dialogFieldSchema, 0);
    
    // Register m_buttonCount field at offset +20
    RegisterSerializedField(this, k_buttonCountField, (uint8_t*)this + 20, 
              &g_dialogFieldSchema, 0);
}

/**
 * dialogData::Validate  @ 0x8240AF20  |  size: 0x6C
 *
 * Slot 2.  Validates the loaded dialog data fields to ensure they are
 * within acceptable ranges.  Logs warnings via nop_8240E6D0 if values
 * are out of bounds, then delegates to the base class validation
 * (xmlNodeStruct_Init).
 * 
 * Validation rules:
 *   - m_dialogType must be in range [1, 209]
 *   - m_buttonCount must be >= 1
 * 
 * The debug strings reference "hsmDebug" @ 0x82075E90, suggesting this
 * validation is part of the HSM (Hierarchical State Machine) debug system.
 */
void dialogData::Validate() {
    // Validate m_dialogType is in valid range [1, 209]
    if (m_dialogType <= 0 || m_dialogType >= 210) {
        // Log validation error for dialog type
        extern const char* k_dialogTypeError;   // @ 0x82075E78 (22 bytes)
        nop_8240E6D0(k_dialogTypeError);
    }
    
    // Validate m_buttonCount is at least 1
    if (m_buttonCount < 1) {
        // Log validation error for button count
        // String references m_dialogType value in error message
        extern const char* k_buttonCountError;  // @ 0x82075E90 (44 bytes, starts with "hsmDebug")
        nop_8240E6D0(k_buttonCountError, m_dialogType);
    }
    
    // Delegate to base class validation (xmlNodeStruct)
    xmlNodeStruct_Init(this);
}

// ─────────────────────────────────────────────────────────────────────────────
// dialogManager  [vtable @ 0x8205B0D0 / secondary @ 0x8205B0DC]
// ─────────────────────────────────────────────────────────────────────────────

/**
 * dialogManager — UNUSED CLASS
 *
 * This class exists in the RTTI data with two vtable pointers but has:
 *   - No virtual methods (beyond base class)
 *   - No field accesses in any function
 *   - No debug string hints
 *   - No global instances
 *   - No references in the recomp output
 *
 * Analysis suggests this was either:
 *   1. A planned dialog management system that was never implemented
 *   2. A development artifact that remained in the RTTI
 *   3. An abstract base that was replaced by pongDialogContext/pongDialogState
 *
 * The actual dialog functionality is implemented through:
 *   - pongDialogContext (HSM context for dialog popups)
 *   - pongDialogState (HSM state for dialog sequences)
 *   - dialogData (data singleton for dialog content)
 *
 * No implementation required - this class is never instantiated or referenced.
 */

// No methods to implement - class is unused
