#!/usr/bin/env python3
"""
Identify CRT Functions
Extracts all CRT functions from symbols.txt based on splits.txt address ranges.
"""

import re
import sys
from pathlib import Path

# CRT address ranges from splits.txt
CRT_RANGES = [
    # src/crt/string.c
    (0x820C0000, 0x820C0038, "src/crt/string.c"),
    (0x82186358, 0x82186418, "src/crt/string.c"),
    
    # src/crt/entry.c
    (0x820C0038, 0x820C00C0, "src/crt/entry.c"),
    (0x820C0128, 0x820C016C, "src/crt/entry.c"),
    (0x82186CA8, 0x82186D98, "src/crt/entry.c"),
    (0x825836E8, 0x825836F4, "src/crt/entry.c"),
    
    # src/crt/heap.c
    (0x821861A0, 0x8218629C, "src/crt/heap.c"),
    (0x82186E40, 0x82187178, "src/crt/heap.c"),
    (0x821871C0, 0x821874D4, "src/crt/heap.c"),
    (0x8242C178, 0x8242C2C0, "src/crt/heap.c"),
    
    # src/crt/startup.c
    (0x8242BD20, 0x8242C178, "src/crt/startup.c"),
    (0x8242C2C0, 0x8242C318, "src/crt/startup.c"),
    (0x8242FB60, 0x8242FB70, "src/crt/startup.c"),
    (0x8242FDC8, 0x8242FED0, "src/crt/startup.c"),
    
    # src/crt/exit.c
    (0x8242F6B0, 0x8242F7B0, "src/crt/exit.c"),
    (0x8242F7D0, 0x8242F7FC, "src/crt/exit.c"),
    (0x8242F9D0, 0x8242FADC, "src/crt/exit.c"),
    
    # src/crt/memory.c
    (0x8242FED0, 0x8242FEF0, "src/crt/memory.c"),
    (0x8242FF70, 0x8242FFAC, "src/crt/memory.c"),
    (0x82434100, 0x82434520, "src/crt/memory.c"),
    
    # src/crt/version.c
    (0x8242BB70, 0x8242BD14, "src/crt/version.c"),
]

def parse_symbols(symbols_file):
    """Parse symbols.txt and return list of (addr, name, size, type)."""
    symbols = []
    
    with open(symbols_file, 'r') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            
            # Parse: name = .text:0xADDR; // type:function size:0xSIZE
            match = re.match(r'(\S+)\s*=\s*\.text:(0x[0-9A-Fa-f]+);\s*//\s*type:(\w+)\s+size:(0x[0-9A-Fa-f]+)', line)
            if match:
                name = match.group(1)
                addr = int(match.group(2), 16)
                sym_type = match.group(3)
                size = int(match.group(4), 16)
                symbols.append((addr, name, size, sym_type))
    
    return symbols

def find_crt_functions(symbols):
    """Find all functions in CRT address ranges."""
    crt_functions = []
    
    for addr, name, size, sym_type in symbols:
        if sym_type != 'function':
            continue
        
        for start, end, source in CRT_RANGES:
            if start <= addr < end:
                crt_functions.append({
                    'addr': addr,
                    'name': name,
                    'size': size,
                    'source': source,
                    'range_start': start,
                    'range_end': end
                })
                break
    
    return crt_functions

def generate_hook_table(crt_functions):
    """Generate C code for hook table."""
    print("// Auto-generated CRT hook table")
    print("// Generated by scripts/identify_crt_functions.py")
    print()
    print("static const CRTHook g_crt_hooks[] = {")
    
    # Group by source file
    by_source = {}
    for func in crt_functions:
        source = func['source']
        if source not in by_source:
            by_source[source] = []
        by_source[source].append(func)
    
    for source in sorted(by_source.keys()):
        print(f"    // {source}")
        for func in sorted(by_source[source], key=lambda x: x['addr']):
            # Check if we have a native implementation
            native_impl = f"NATIVE_{func['name']}" if func['name'] in [
                'strlen', 'memcpy', 'memset', 'memset_aligned', 'memmove', 'memcmp',
                'malloc', 'free', 'calloc', 'realloc'
            ] else "NULL"
            
            print(f"    {{ 0x{func['addr']:08X}, \"{func['name']}\", "
                  f"(void*){native_impl}, 0x{func['size']:X}, \"{source}\" }},")
        print()
    
    print("    // Sentinel")
    print("    { 0, NULL, NULL, 0, NULL }")
    print("};")

def main():
    if len(sys.argv) < 2:
        print("Usage: identify_crt_functions.py <symbols.txt>")
        sys.exit(1)
    
    symbols_file = sys.argv[1]
    
    print(f"Parsing {symbols_file}...", file=sys.stderr)
    symbols = parse_symbols(symbols_file)
    print(f"Found {len(symbols)} total symbols", file=sys.stderr)
    
    print(f"Identifying CRT functions...", file=sys.stderr)
    crt_functions = find_crt_functions(symbols)
    print(f"Found {len(crt_functions)} CRT functions", file=sys.stderr)
    
    print("\n=== CRT Functions by Source File ===", file=sys.stderr)
    by_source = {}
    for func in crt_functions:
        source = func['source']
        if source not in by_source:
            by_source[source] = []
        by_source[source].append(func)
    
    for source in sorted(by_source.keys()):
        print(f"\n{source}: {len(by_source[source])} functions", file=sys.stderr)
        for func in sorted(by_source[source], key=lambda x: x['addr']):
            print(f"  0x{func['addr']:08X}  {func['name']:30s}  {func['size']:4d} bytes", file=sys.stderr)
    
    print("\n=== Generating Hook Table ===\n", file=sys.stderr)
    generate_hook_table(crt_functions)

if __name__ == '__main__':
    main()
